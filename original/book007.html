<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Fruitful functions</TITLE>
</HEAD>
<BODY >
<A HREF="book006.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="book008.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc72"><FONT COLOR=black><FONT SIZE=3>Chapter&#XA0;6</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Fruitful functions</FONT></FONT></H1><P><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="fruitchap"></A></P><H2 CLASS="section"><A NAME="toc65"></A><A NAME="htoc73"><FONT COLOR=black><FONT SIZE=3>6.1</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Return values</FONT></FONT></H2><P><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default440"></A></P><P><FONT COLOR=black><FONT SIZE=3>Some of the built-in functions we have used, such as the math
functions, produce results. Calling the function generates a
value, which we usually assign to a variable or use as part of an
expression.</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>e = math.exp(1.0)
height = radius * math.sin(radians)
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>All of the functions we have written so far are void; they print
something or move turtles around, but their return value is </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>None</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>In this chapter, we are (finally) going to write fruitful functions.
The first example is </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>area</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, which returns the area of a circle
with the given radius:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def area(radius):
    temp = math.pi * radius**2
    return temp
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>We have seen the </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>return</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> statement before, but in a fruitful
function the </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>return</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> statement includes
an expression. This statement means: &#X201C;Return immediately from
this function and use the following expression as a return value.&#X201D;
The expression can be arbitrarily complicated, so we could
have written this function more concisely:</FONT></FONT></P><P><A NAME="@default441"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default442"></A></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def area(radius):
    return math.pi * radius**2
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>On the other hand, </FONT></FONT><FONT COLOR=black><FONT SIZE=3><B>temporary variables</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3> like </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>temp</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> often make
debugging easier.</FONT></FONT></P><P><A NAME="@default443"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default444"></A></P><P><FONT COLOR=black><FONT SIZE=3>Sometimes it is useful to have multiple return statements, one in each
branch of a conditional:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def absolute_value(x):
    if x &lt; 0:
        return -x
    else:
        return x
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>Since these </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>return</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> statements are in an alternative conditional,
only one will be executed.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>As soon as a return statement executes, the function
terminates without executing any subsequent statements.
Code that appears after a </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>return</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> statement, or any other place
the flow of execution can never reach, is called </FONT></FONT><FONT COLOR=black><FONT SIZE=3><B>dead code</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>.</FONT></FONT></P><P><A NAME="@default445"></A></P><P><FONT COLOR=black><FONT SIZE=3>In a fruitful function, it is a good idea to ensure
that every possible path through the program hits a
</FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>return</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> statement. For example:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def absolute_value(x):
    if x &lt; 0:
        return -x
    if x &gt; 0:
        return x
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>This function is incorrect because if </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>x</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> happens to be 0,
neither condition is true, and the function ends without hitting a
</FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>return</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> statement. If the flow of execution gets to the end
of a function, the return value is </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>None</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, which is not
the absolute value of 0.</FONT></FONT></P><P><A NAME="@default446"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default447"></A></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>&gt;&gt;&gt; print absolute_value(0)
None
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>By the way, Python provides a built-in function called 
</FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>abs</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> that computes absolute values.</FONT></FONT></P><P><A NAME="@default448"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default449"></A></P><DIV CLASS="theorem"><FONT COLOR=black><FONT SIZE=3><B>Exercise&#XA0;1</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;</FONT></FONT><P><A NAME="@default450"></A><FONT COLOR=black><FONT SIZE=3><EM>
</EM></FONT></FONT><A NAME="@default451"></A></P><P><FONT COLOR=black><FONT SIZE=3><EM>Write a </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>compare</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> function
that returns </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>1</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> if </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>x &gt; y</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>,
</EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>0</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> if </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>x == y</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>, and </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>-1</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> if </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>x &lt; y</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>.
</EM></FONT></FONT></P></DIV><H2 CLASS="section"><A NAME="toc66"></A><A NAME="htoc74"><FONT COLOR=black><FONT SIZE=3>6.2</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Incremental development</FONT></FONT></H2><P><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="incremental development"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default452"></A></P><P><FONT COLOR=black><FONT SIZE=3>As you write larger functions, you might find yourself
spending more time debugging.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>To deal with increasingly complex programs,
you might want to try a process called
</FONT></FONT><FONT COLOR=black><FONT SIZE=3><B>incremental development</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>. The goal of incremental development
is to avoid long debugging sessions by adding and testing only
a small amount of code at a time.</FONT></FONT></P><P><A NAME="@default453"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default454"></A></P><P><FONT COLOR=black><FONT SIZE=3>As an example, suppose you want to find the distance between two
points, given by the coordinates </FONT></FONT><FONT COLOR=black><FONT SIZE=3>(<I>x</I></FONT></FONT><SUB><FONT COLOR=black><FONT SIZE=3>1</FONT></FONT></SUB><FONT COLOR=black><FONT SIZE=3>, <I>y</I></FONT></FONT><SUB><FONT COLOR=black><FONT SIZE=3>1</FONT></FONT></SUB><FONT COLOR=black><FONT SIZE=3>)</FONT></FONT><FONT COLOR=black><FONT SIZE=3> and </FONT></FONT><FONT COLOR=black><FONT SIZE=3>(<I>x</I></FONT></FONT><SUB><FONT COLOR=black><FONT SIZE=3>2</FONT></FONT></SUB><FONT COLOR=black><FONT SIZE=3>, <I>y</I></FONT></FONT><SUB><FONT COLOR=black><FONT SIZE=3>2</FONT></FONT></SUB><FONT COLOR=black><FONT SIZE=3>)</FONT></FONT><FONT COLOR=black><FONT SIZE=3>.
By the Pythagorean theorem, the distance is:</FONT></FONT></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT COLOR=black><FONT SIZE=3><I>distance</I></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;=&#XA0;</FONT></FONT></TD><TD CLASS="dcell"><FONT COLOR=black><FONT SIZE=5>&#X221A;</FONT></FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"><FONT COLOR=black><FONT SIZE=3></FONT></FONT></TD></TR>
<TR><TD ALIGN=center NOWRAP><FONT COLOR=black><FONT SIZE=3>(<I>x</I></FONT></FONT><SUB><FONT COLOR=black><FONT SIZE=3>2</FONT></FONT></SUB><FONT COLOR=black><FONT SIZE=3>&#XA0;&#X2212;&#XA0;<I>x</I></FONT></FONT><SUB><FONT COLOR=black><FONT SIZE=3>1</FONT></FONT></SUB><FONT COLOR=black><FONT SIZE=3>)</FONT></FONT><SUP><FONT COLOR=black><FONT SIZE=3>2</FONT></FONT></SUP><FONT COLOR=black><FONT SIZE=3>&#XA0;+&#XA0;(<I>y</I></FONT></FONT><SUB><FONT COLOR=black><FONT SIZE=3>2</FONT></FONT></SUB><FONT COLOR=black><FONT SIZE=3>&#XA0;&#X2212;&#XA0;<I>y</I></FONT></FONT><SUB><FONT COLOR=black><FONT SIZE=3>1</FONT></FONT></SUB><FONT COLOR=black><FONT SIZE=3>)</FONT></FONT><SUP><FONT COLOR=black><FONT SIZE=3>2</FONT></FONT></SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P><FONT COLOR=black><FONT SIZE=3>
The first step is to consider what a </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>distance</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> function should
look like in Python. In other words, what are the inputs (parameters)
and what is the output (return value)?</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>In this case, the inputs are two points, which you can represent
using four numbers. The return value is the distance, which is
a floating-point value.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>Already you can write an outline of the function:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def distance(x1, y1, x2, y2):
    return 0.0
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>Obviously, this version doesn&#X2019;t compute distances; it always returns
zero. But it is syntactically correct, and it runs, which means that
you can test it before you make it more complicated.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>To test the new function, call it with sample arguments:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>&gt;&gt;&gt; distance(1, 2, 4, 6)
0.0
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>I chose these values so that the horizontal distance is 3 and the
vertical distance is 4; that way, the result is 5
(the hypotenuse of a 3-4-5 triangle). When testing a function, it is
useful to know the right answer.</FONT></FONT></P><P><A NAME="@default455"></A></P><P><FONT COLOR=black><FONT SIZE=3>At this point we have confirmed that the function is syntactically
correct, and we can start adding code to the body.
A reasonable next step is to find the differences
</FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>x</I></FONT></FONT><SUB><FONT COLOR=black><FONT SIZE=3>2</FONT></FONT></SUB><FONT COLOR=black><FONT SIZE=3> &#X2212; <I>x</I></FONT></FONT><SUB><FONT COLOR=black><FONT SIZE=3>1</FONT></FONT></SUB><FONT COLOR=black><FONT SIZE=3> and </FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>y</I></FONT></FONT><SUB><FONT COLOR=black><FONT SIZE=3>2</FONT></FONT></SUB><FONT COLOR=black><FONT SIZE=3> &#X2212; <I>y</I></FONT></FONT><SUB><FONT COLOR=black><FONT SIZE=3>1</FONT></FONT></SUB><FONT COLOR=black><FONT SIZE=3>. The next version stores those values in
temporary variables and prints them.</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    print 'dx is', dx
    print 'dy is', dy
    return 0.0
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>If the function is working, it should display </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>&#X2019;dx is 3&#X2019;</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> and </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>&#X2019;dy is 4&#X2019;</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>. If so, we know that the function is getting the right
arguments and performing the first computation correctly. If not,
there are only a few lines to check.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>Next we compute the sum of squares of </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>dx</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> and </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>dy</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquared = dx**2 + dy**2
    print 'dsquared is: ', dsquared
    return 0.0
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>Again, you would run the program at this stage and check the output
(which should be 25).
Finally, you can use </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>math.sqrt</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> to compute and return the result:</FONT></FONT></P><P><A NAME="@default456"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default457"></A></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquared = dx**2 + dy**2
    result = math.sqrt(dsquared)
    return result
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>If that works correctly, you are done. Otherwise, you might
want to print the value of </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>result</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> before the return
statement.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>The final version of the function doesn&#X2019;t display anything when it
runs; it only returns a value. The </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>print</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> statements we wrote
are useful for debugging, but once you get the function working, you
should remove them. Code like that is called </FONT></FONT><FONT COLOR=black><FONT SIZE=3><B>scaffolding</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>
because it is helpful for building the program but is not part of the
final product.</FONT></FONT></P><P><A NAME="@default458"></A></P><P><FONT COLOR=black><FONT SIZE=3>When you start out, you should add only a line or two of code at a
time. As you gain more experience, you might find yourself writing
and debugging bigger chunks. Either way, incremental development
can save you a lot of debugging time.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>The key aspects of the process are:</FONT></FONT></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><FONT COLOR=black><FONT SIZE=3>Start with a working program and make small incremental changes. 
At any point, if there is an error, you should have a good idea
where it is.</FONT></FONT></LI><LI CLASS="li-enumerate"><FONT COLOR=black><FONT SIZE=3>Use temporary variables to hold intermediate values so you can
display and check them.</FONT></FONT></LI><LI CLASS="li-enumerate"><FONT COLOR=black><FONT SIZE=3>Once the program is working, you might want to remove some of
the scaffolding or consolidate multiple statements into compound
expressions, but only if it does not make the program difficult to
read.</FONT></FONT></LI></OL><DIV CLASS="theorem"><FONT COLOR=black><FONT SIZE=3><B>Exercise&#XA0;2</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;</FONT></FONT><P><A NAME="@default459"></A></P><P><FONT COLOR=black><FONT SIZE=3><EM>Use incremental development to write a function
called </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>hypotenuse</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> that returns the length of the hypotenuse of a
right triangle given the lengths of the two legs as arguments.
Record each stage of the development process as you go.
</EM></FONT></FONT></P></DIV><H2 CLASS="section"><A NAME="toc67"></A><A NAME="htoc75"><FONT COLOR=black><FONT SIZE=3>6.3</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Composition</FONT></FONT></H2><P><A NAME="@default460"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default461"></A></P><P><FONT COLOR=black><FONT SIZE=3>As you should expect by now, you can call one function from
within another. This ability is called </FONT></FONT><FONT COLOR=black><FONT SIZE=3><B>composition</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>As an example, we&#X2019;ll write a function that takes two points,
the center of the circle and a point on the perimeter, and computes
the area of the circle.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>Assume that the center point is stored in the variables </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>xc</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> and
</FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>yc</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, and the perimeter point is in </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>xp</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> and </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>yp</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>. The
first step is to find the radius of the circle, which is the distance
between the two points. We just wrote a function, </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>distance</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, that does that:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>radius = distance(xc, yc, xp, yp)
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>The next step is to find the area of a circle with that radius;
we just wrote that, too:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>result = area(radius)
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>Encapsulating these steps in a function, we get:</FONT></FONT></P><P><A NAME="@default462"></A></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def circle_area(xc, yc, xp, yp):
    radius = distance(xc, yc, xp, yp)
    result = area(radius)
    return result
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>The temporary variables </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>radius</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> and </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>result</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> are useful for
development and debugging, but once the program is working, we can
make it more concise by composing the function calls:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def circle_area(xc, yc, xp, yp):
    return area(distance(xc, yc, xp, yp))
</FONT></FONT></PRE><H2 CLASS="section"><A NAME="toc68"></A><A NAME="htoc76"><FONT COLOR=black><FONT SIZE=3>6.4</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Boolean functions</FONT></FONT></H2><P><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="boolean"></A></P><P><A NAME="@default463"></A></P><P><FONT COLOR=black><FONT SIZE=3>Functions can return booleans, which is often convenient for hiding
complicated tests inside functions. For example:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def is_divisible(x, y):
    if x % y == 0:
        return True
    else:
        return False
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>It is common to give boolean functions names that sound like yes/no
questions; </FONT></FONT><CODE><FONT COLOR=black><FONT SIZE=3>is_divisible</FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3> returns either </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>True</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> or </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>False</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>
to indicate whether </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>x</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> is divisible by </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>y</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>Here is an example:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>&gt;&gt;&gt;   is_divisible(6, 4)
False
&gt;&gt;&gt;   is_divisible(6, 3)
True
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>The result of the </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>==</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> operator is a boolean, so we can write the
function more concisely by returning it directly:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def is_divisible(x, y):
    return x % y == 0
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>Boolean functions are often used in conditional statements:</FONT></FONT></P><P><A NAME="@default464"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default465"></A></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>if is_divisible(x, y):
    print 'x is divisible by y'
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>It might be tempting to write something like:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>if is_divisible(x, y) == True:
    print 'x is divisible by y'
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>But the extra comparison is unnecessary.</FONT></FONT></P><DIV CLASS="theorem"><FONT COLOR=black><FONT SIZE=3><B>Exercise&#XA0;3</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;<EM>
Write a function </EM></FONT></FONT><CODE><FONT COLOR=black><FONT SIZE=3><EM>is_between(x, y, z)</EM></FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3><EM> that
returns </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>True</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> if </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><I>x</I> &#X2264; <I>y</I> &#X2264; <I>z</I></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> or </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>False</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> otherwise.
</EM></FONT></FONT></DIV><H2 CLASS="section"><A NAME="toc69"></A><A NAME="htoc77"><FONT COLOR=black><FONT SIZE=3>6.5</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;More recursion</FONT></FONT></H2><P><A NAME="@default466"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default467"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default468"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default469"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default470"></A></P><P><FONT COLOR=black><FONT SIZE=3>We have only covered a small subset of Python, but you might
be interested to know that this subset is a </FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>complete</EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3>
programming language, which means that anything that can be
computed can be expressed in this language. Any program ever written
could be rewritten using only the language features you have learned
so far (actually, you would need a few commands to control devices
like the keyboard, mouse, disks, etc., but that&#X2019;s all).</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>Proving that claim is a nontrivial exercise first accomplished by Alan
Turing, one of the first computer scientists (some would argue that he
was a mathematician, but a lot of early computer scientists started as
mathematicians). Accordingly, it is known as the Turing Thesis.
For a more complete (and accurate) discussion of the Turing Thesis,
I recommend Michael Sipser&#X2019;s book </FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>Introduction to the
Theory of Computation</EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3>.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>To give you an idea of what you can do with the tools you have learned
so far, we&#X2019;ll evaluate a few recursively defined mathematical
functions. A recursive definition is similar to a circular
definition, in the sense that the definition contains a reference to
the thing being defined. A truly circular definition is not very
useful:</FONT></FONT></P><DL CLASS="description"><DT CLASS="dt-description"><FONT COLOR=black><FONT SIZE=3><B>frabjuous:</B></FONT></FONT></DT><DD CLASS="dd-description"><FONT COLOR=black><FONT SIZE=3> An adjective used to describe something that is frabjuous.</FONT></FONT></DD></DL><P><A NAME="@default471"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default472"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default473"></A></P><P><FONT COLOR=black><FONT SIZE=3>If you saw that definition in the dictionary, you might be annoyed. On
the other hand, if you looked up the definition of the factorial
function, denoted with the symbol </FONT></FONT><FONT COLOR=black><FONT SIZE=3>!</FONT></FONT><FONT COLOR=black><FONT SIZE=3>, you might get something like
this:</FONT></FONT></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><FONT COLOR=black><FONT SIZE=3>&nbsp;</FONT></FONT></TD><TD ALIGN=center NOWRAP><FONT COLOR=black><FONT SIZE=3>&nbsp;</FONT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=black><FONT SIZE=3>0!&#XA0;=&#XA0;1&#XA0;</FONT></FONT></TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=black><FONT SIZE=3>&nbsp;</FONT></FONT></TD><TD ALIGN=center NOWRAP><FONT COLOR=black><FONT SIZE=3>&nbsp;</FONT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=black><FONT SIZE=3><I>n</I>!&#XA0;=&#XA0;<I>n</I>&#XA0;(<I>n</I>&#X2212;1)!</FONT></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE><P><FONT COLOR=black><FONT SIZE=3>This definition says that the factorial of 0 is 1, and the factorial
of any other value, </FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>n</I></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, is </FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>n</I></FONT></FONT><FONT COLOR=black><FONT SIZE=3> multiplied by the factorial of </FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>n</I>&#X2212;1</FONT></FONT><FONT COLOR=black><FONT SIZE=3>.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>So </FONT></FONT><FONT COLOR=black><FONT SIZE=3>3!</FONT></FONT><FONT COLOR=black><FONT SIZE=3> is 3 times </FONT></FONT><FONT COLOR=black><FONT SIZE=3>2!</FONT></FONT><FONT COLOR=black><FONT SIZE=3>, which is 2 times </FONT></FONT><FONT COLOR=black><FONT SIZE=3>1!</FONT></FONT><FONT COLOR=black><FONT SIZE=3>, which is 1 times
</FONT></FONT><FONT COLOR=black><FONT SIZE=3>0!</FONT></FONT><FONT COLOR=black><FONT SIZE=3>. Putting it all together, </FONT></FONT><FONT COLOR=black><FONT SIZE=3>3!</FONT></FONT><FONT COLOR=black><FONT SIZE=3> equals 3 times 2 times 1 times 1,
which is 6.</FONT></FONT></P><P><A NAME="@default474"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default475"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default476"></A></P><P><FONT COLOR=black><FONT SIZE=3>If you can write a recursive definition of something, you can usually
write a Python program to evaluate it. The first step is to decide
what the parameters should be. In this case it should be clear
that </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>factorial</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> takes an integer:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def factorial(n):
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>If the argument happens to be 0, all we have to do is return 1:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def factorial(n):
    if n == 0:
        return 1
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>Otherwise, and this is the interesting part, we have to make a
recursive call to find the factorial of </FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>n</I>&#X2212;1</FONT></FONT><FONT COLOR=black><FONT SIZE=3> and then multiply it by
</FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>n</I></FONT></FONT><FONT COLOR=black><FONT SIZE=3>:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def factorial(n):
    if n == 0:
        return 1
    else:
        recurse = factorial(n-1)
        result = n * recurse
        return result
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>The flow of execution for this program is similar to the flow of </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>countdown</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> in Section&#XA0;</FONT></FONT><A HREF="book006.html#recursion"><FONT COLOR=black><FONT SIZE=3>5.8</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>. If we call </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>factorial</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>
with the value 3:</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>Since 3 is not 0, we take the second branch and calculate the factorial
of </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>n-1</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>...</FONT></FONT></P><BLOCKQUOTE CLASS="quote"><FONT COLOR=black><FONT SIZE=3>
Since 2 is not 0, we take the second branch and calculate the factorial of
</FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>n-1</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>...</FONT></FONT><BLOCKQUOTE CLASS="quote"><FONT COLOR=black><FONT SIZE=3>
Since 1 is not 0, we take the second branch and calculate the factorial
of </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>n-1</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>...</FONT></FONT><BLOCKQUOTE CLASS="quote"><FONT COLOR=black><FONT SIZE=3>
Since 0 </FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>is</EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3> 0, we take the first branch and return 1
without making any more recursive calls.
</FONT></FONT></BLOCKQUOTE><P><FONT COLOR=black><FONT SIZE=3>The return value (1) is multiplied by </FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>n</I></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, which is 1, and the
result is returned.
</FONT></FONT></P></BLOCKQUOTE><P><FONT COLOR=black><FONT SIZE=3>The return value (1) is multiplied by </FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>n</I></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, which is 2, and the
result is returned.
</FONT></FONT></P></BLOCKQUOTE><P><FONT COLOR=black><FONT SIZE=3>The return value (2) is multiplied by </FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>n</I></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, which is 3, and the result, 6,
becomes the return value of the function call that started the whole
process.</FONT></FONT></P><P><A NAME="@default477"></A></P><P><FONT COLOR=black><FONT SIZE=3>Here is what the stack diagram looks like for this sequence of function
calls:</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3><BR>

</FONT></FONT></P><DIV CLASS="center"><FONT COLOR=black><FONT SIZE=3><IMG SRC="book009.png"></FONT></FONT></DIV><P><FONT COLOR=black><FONT SIZE=3>
<BR>
</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>The return values are shown being passed back up the stack. In each
frame, the return value is the value of </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>result</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, which is the
product of </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>n</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> and </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>recurse</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>.</FONT></FONT></P><P><A NAME="@default478"></A></P><P><FONT COLOR=black><FONT SIZE=3>In the last frame, the local
variables </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>recurse</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> and </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>result</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> do not exist, because
the branch that creates them does not execute.</FONT></FONT></P><H2 CLASS="section"><A NAME="toc70"></A><A NAME="htoc78"><FONT COLOR=black><FONT SIZE=3>6.6</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Leap of faith</FONT></FONT></H2><P><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default479"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default480"></A></P><P><FONT COLOR=black><FONT SIZE=3>Following the flow of execution is one way to read programs, but
it can quickly become labyrinthine. An
alternative is what I call the &#X201C;leap of faith.&#X201D; When you come to a
function call, instead of following the flow of execution, you </FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>assume</EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3> that the function works correctly and returns the right
result.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>In fact, you are already practicing this leap of faith when you use
built-in functions. When you call </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>math.cos</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> or </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>math.exp</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>,
you don&#X2019;t examine the bodies of those functions. You just
assume that they work because the people who wrote the built-in
functions were good programmers.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>The same is true when you call one of your own functions. For
example, in Section&#XA0;</FONT></FONT><A HREF="#boolean"><FONT COLOR=black><FONT SIZE=3>6.4</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>, we wrote a function called 
</FONT></FONT><CODE><FONT COLOR=black><FONT SIZE=3>is_divisible</FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3> that determines whether one number is divisible by
another. Once we have convinced ourselves that this function is
correct&#X2014;by examining the code and testing&#X2014;we can use the function
without looking at the body again.</FONT></FONT></P><P><A NAME="@default481"></A></P><P><FONT COLOR=black><FONT SIZE=3>The same is true of recursive programs. When you get to the recursive
call, instead of following the flow of execution, you should assume
that the recursive call works (yields the correct result) and then ask
yourself, &#X201C;Assuming that I can find the factorial of </FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>n</I>&#X2212;1</FONT></FONT><FONT COLOR=black><FONT SIZE=3>, can I
compute the factorial of </FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>n</I></FONT></FONT><FONT COLOR=black><FONT SIZE=3>?&#X201D; In this case, it is clear that you
can, by multiplying by </FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>n</I></FONT></FONT><FONT COLOR=black><FONT SIZE=3>.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>Of course, it&#X2019;s a bit strange to assume that the function works
correctly when you haven&#X2019;t finished writing it, but that&#X2019;s why
it&#X2019;s called a leap of faith!</FONT></FONT></P><H2 CLASS="section"><A NAME="toc71"></A><A NAME="htoc79"><FONT COLOR=black><FONT SIZE=3>6.7</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;One more example</FONT></FONT></H2><P><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="one more example"></A></P><P><A NAME="@default482"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default483"></A></P><P><FONT COLOR=black><FONT SIZE=3>After </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>factorial</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, the most common example of a recursively
defined mathematical function is </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>fibonacci</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, which has the
following definition</FONT></FONT><SUP><A NAME="text8" HREF="#note8"><FONT COLOR=black><FONT SIZE=3>1</FONT></FONT></A></SUP><FONT COLOR=black><FONT SIZE=3>:</FONT></FONT></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><FONT COLOR=black><FONT SIZE=3>&nbsp;</FONT></FONT></TD><TD ALIGN=center NOWRAP><FONT COLOR=black><FONT SIZE=3>&nbsp;</FONT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=black><FONT SIZE=3><I>fibonacci</I></FONT></FONT><FONT COLOR=black><FONT SIZE=3>(0)&#XA0;=&#XA0;0&#XA0;</FONT></FONT></TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=black><FONT SIZE=3>&nbsp;</FONT></FONT></TD><TD ALIGN=center NOWRAP><FONT COLOR=black><FONT SIZE=3>&nbsp;</FONT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=black><FONT SIZE=3><I>fibonacci</I></FONT></FONT><FONT COLOR=black><FONT SIZE=3>(1)&#XA0;=&#XA0;1&#XA0;</FONT></FONT></TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=black><FONT SIZE=3>&nbsp;</FONT></FONT></TD><TD ALIGN=center NOWRAP><FONT COLOR=black><FONT SIZE=3>&nbsp;</FONT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=black><FONT SIZE=3><I>fibonacci</I></FONT></FONT><FONT COLOR=black><FONT SIZE=3>(<I>n</I>)&#XA0;=&#XA0;</FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>fibonacci</I></FONT></FONT><FONT COLOR=black><FONT SIZE=3>(<I>n</I>&#X2212;1)&#XA0;+&#XA0;</FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>fibonacci</I></FONT></FONT><FONT COLOR=black><FONT SIZE=3>(<I>n</I>&#X2212;2);</FONT></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE><P><FONT COLOR=black><FONT SIZE=3>
Translated into Python, it looks like this:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def fibonacci (n):
    if n == 0:
        return 0
    elif  n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>If you try to follow the flow of execution here, even for fairly
small values of </FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>n</I></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, your head explodes. But according to the
leap of faith, if you assume that the two recursive calls
work correctly, then it is clear that you get
the right result by adding them together.</FONT></FONT></P><P><A NAME="@default484"></A></P><H2 CLASS="section"><A NAME="toc72"></A><A NAME="htoc80"><FONT COLOR=black><FONT SIZE=3>6.8</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Checking types</FONT></FONT></H2><P><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="guardian"></A></P><P><A NAME="@default485"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default486"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default487"></A></P><P><FONT COLOR=black><FONT SIZE=3>What happens if we call </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>factorial</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> and give it 1.5 as an argument?</FONT></FONT></P><P><A NAME="@default488"></A></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>&gt;&gt;&gt; factorial(1.5)
RuntimeError: Maximum recursion depth exceeded
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>It looks like an infinite recursion. But how can that be? There is a
base case&#X2014;when </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>n == 0</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>. But if </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>n</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> is not an integer,
we can </FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>miss</EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3> the base case and recurse forever.</FONT></FONT></P><P><A NAME="@default489"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default490"></A></P><P><FONT COLOR=black><FONT SIZE=3>In the first recursive call, the value of </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>n</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> is 0.5.
In the next, it is -0.5. From there, it gets smaller
(more negative), but it will never be 0.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>We have two choices. We can try to generalize the </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>factorial</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>
function to work with floating-point numbers, or we can make </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>factorial</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> check the type of its argument. The first option is
called the gamma function</FONT></FONT><SUP><A NAME="text9" HREF="#note9"><FONT COLOR=black><FONT SIZE=3>2</FONT></FONT></A></SUP><FONT COLOR=black><FONT SIZE=3> and it&#X2019;s a
little beyond the scope of this book. So we&#X2019;ll go for the second.</FONT></FONT></P><P><A NAME="@default491"></A></P><P><FONT COLOR=black><FONT SIZE=3>We can use the built-in function </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>isinstance</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> to verify the type
of the argument. While we&#X2019;re at it, we can also make sure the
argument is positive:</FONT></FONT></P><P><A NAME="@default492"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default493"></A></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def factorial (n):
    if not isinstance(n, int):
        print 'Factorial is only defined for integers.'
        return None
    elif n &lt; 0:
        print 'Factorial is only defined for positive integers.'
        return None
    elif n == 0:
        return 1
    else:
        return n * factorial(n-1)
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>The first base case handles nonintegers; the
second catches negative integers. In both cases, the program prints
an error message and returns </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>None</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> to indicate that something
went wrong:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>&gt;&gt;&gt; factorial('fred')
Factorial is only defined for integers.
None
&gt;&gt;&gt; factorial(-2)
Factorial is only defined for positive integers.
None
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>If we get past both checks, then we know that </FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>n</I></FONT></FONT><FONT COLOR=black><FONT SIZE=3> is a positive
integer, and we can prove that the recursion terminates.</FONT></FONT></P><P><A NAME="@default494"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default495"></A></P><P><FONT COLOR=black><FONT SIZE=3>This program demonstrates a pattern sometimes called a </FONT></FONT><FONT COLOR=black><FONT SIZE=3><B>guardian</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>.
The first two conditionals act as guardians, protecting the code that
follows from values that might cause an error. The guardians make it
possible to prove the correctness of the code.</FONT></FONT></P><H2 CLASS="section"><A NAME="toc73"></A><A NAME="htoc81"><FONT COLOR=black><FONT SIZE=3>6.9</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Debugging</FONT></FONT></H2><P><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="factdebug"></A></P><P><A NAME="@default496"></A></P><P><FONT COLOR=black><FONT SIZE=3>Breaking a large program into smaller functions creates natural
checkpoints for debugging. If a function is not working, there are
three possibilities to consider:</FONT></FONT></P><UL CLASS="itemize"><LI CLASS="li-itemize"><FONT COLOR=black><FONT SIZE=3>There is something wrong with the arguments the function
is getting; a precondition is violated.</FONT></FONT></LI><LI CLASS="li-itemize"><FONT COLOR=black><FONT SIZE=3>There is something wrong with the function; a postcondition
is violated.</FONT></FONT></LI><LI CLASS="li-itemize"><FONT COLOR=black><FONT SIZE=3>There is something wrong with the return value or the
way it is being used.</FONT></FONT></LI></UL><P><FONT COLOR=black><FONT SIZE=3>To rule out the first possibility, you can add a </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>print</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> statement
at the beginning of the function and display the values of the
parameters (and maybe their types). Or you can write code
that checks the preconditions explicitly.</FONT></FONT></P><P><A NAME="@default497"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default498"></A></P><P><FONT COLOR=black><FONT SIZE=3>If the parameters look good, add a </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>print</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> statement before each
</FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>return</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> statement that displays the return value. If
possible, check the result by hand. Consider calling the
function with values that make it easy to check the result
(as in Section&#XA0;</FONT></FONT><A HREF="#incremental development"><FONT COLOR=black><FONT SIZE=3>6.2</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>).</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>If the function seems to be working, look at the function call
to make sure the return value is being used correctly (or used
at all!).</FONT></FONT></P><P><A NAME="@default499"></A></P><P><FONT COLOR=black><FONT SIZE=3>Adding print statements at the beginning and end of a function
can help make the flow of execution more visible.
For example, here is a version of </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>factorial</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> with
print statements:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def factorial(n):
    space = ' ' * (4 * n)
    print space, 'factorial', n
    if n == 0:
        print space, 'returning 1'
        return 1
    else:
        recurse = factorial(n-1)
        result = n * recurse
        print space, 'returning', result
        return result
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3><TT>space</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> is a string of space characters that controls the
indentation of the output. Here is the result of </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>factorial(5)</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> :</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>                     factorial 5
                 factorial 4
             factorial 3
         factorial 2
     factorial 1
 factorial 0
 returning 1
     returning 1
         returning 2
             returning 6
                 returning 24
                     returning 120
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>If you are confused about the flow of execution, this kind of
output can be helpful. It takes some time to develop effective
scaffolding, but a little bit of scaffolding can save a lot of debugging.</FONT></FONT></P><H2 CLASS="section"><A NAME="toc74"></A><A NAME="htoc82"><FONT COLOR=black><FONT SIZE=3>6.10</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Glossary</FONT></FONT></H2><DL CLASS="description"><DT CLASS="dt-description"><FONT COLOR=black><FONT SIZE=3><B>temporary variable:</B></FONT></FONT></DT><DD CLASS="dd-description"><FONT COLOR=black><FONT SIZE=3> A variable used to store an intermediate value in
a complex calculation.
</FONT></FONT><A NAME="@default500"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default501"></A></DD><DT CLASS="dt-description"><FONT COLOR=black><FONT SIZE=3><B>dead code:</B></FONT></FONT></DT><DD CLASS="dd-description"><FONT COLOR=black><FONT SIZE=3> Part of a program that can never be executed, often because
it appears after a </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>return</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> statement.
</FONT></FONT><A NAME="@default502"></A></DD><DT CLASS="dt-description"><FONT COLOR=black><FONT SIZE=3><B><TT>None</TT></B></FONT></FONT><FONT COLOR=black><FONT SIZE=3><B>:</B></FONT></FONT></DT><DD CLASS="dd-description"><FONT COLOR=black><FONT SIZE=3> A special value returned by functions that
have no return statement or a return statement without an argument.
</FONT></FONT><A NAME="@default503"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default504"></A></DD><DT CLASS="dt-description"><FONT COLOR=black><FONT SIZE=3><B>incremental development:</B></FONT></FONT></DT><DD CLASS="dd-description"><FONT COLOR=black><FONT SIZE=3> A program development plan intended to
avoid debugging by adding and testing only
a small amount of code at a time.
</FONT></FONT><A NAME="@default505"></A></DD><DT CLASS="dt-description"><FONT COLOR=black><FONT SIZE=3><B>scaffolding:</B></FONT></FONT></DT><DD CLASS="dd-description"><FONT COLOR=black><FONT SIZE=3> Code that is used during program development but is
not part of the final version.
</FONT></FONT><A NAME="@default506"></A></DD><DT CLASS="dt-description"><FONT COLOR=black><FONT SIZE=3><B>guardian:</B></FONT></FONT></DT><DD CLASS="dd-description"><FONT COLOR=black><FONT SIZE=3> A programming pattern that uses a conditional
statement to check for and handle circumstances that
might cause an error.
</FONT></FONT><A NAME="@default507"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default508"></A></DD></DL><H2 CLASS="section"><A NAME="toc75"></A><A NAME="htoc83"><FONT COLOR=black><FONT SIZE=3>6.11</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Exercises</FONT></FONT></H2><DIV CLASS="theorem"><FONT COLOR=black><FONT SIZE=3><B>Exercise&#XA0;4</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;<EM>
</EM></FONT></FONT><A NAME="@default509"></A><P><FONT COLOR=black><FONT SIZE=3><EM>Draw a stack diagram for the following
program. What does the program print?</EM></FONT></FONT></P><PRE CLASS="verbatim"><EM><FONT COLOR=blue><FONT SIZE=4>def b(z):
    prod = a(z, z)
    print z, prod
    return prod

def a(x, y):
    x = x + 1
    return x * y

def c(x, y, z):
    sum = x + y + z
    pow = b(sum)**2
    return pow

x = 1
y = x + 1
print c(x, y+3, x+y)
</FONT></FONT></EM></PRE></DIV><DIV CLASS="theorem"><FONT COLOR=black><FONT SIZE=3><B>Exercise&#XA0;5</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;<EM>
</EM></FONT></FONT><A NAME="@default510"></A><FONT COLOR=black><FONT SIZE=3><EM>
</EM></FONT></FONT><A NAME="@default511"></A><P><FONT COLOR=black><FONT SIZE=3><EM>The Ackermann function, </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><I>A</I>(<I>m</I>, <I>n</I>)</EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> is defined</EM></FONT></FONT><SUP><A NAME="text10" HREF="#note10"><FONT COLOR=black><FONT SIZE=3><EM>3</EM></FONT></FONT></A></SUP><FONT COLOR=black><FONT SIZE=3><EM>:</EM></FONT></FONT></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT COLOR=black><FONT SIZE=3><EM>


&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</EM></FONT></FONT></TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT COLOR=black><FONT SIZE=3><EM><I>A</I>(<I>m</I>,&#XA0;<I>n</I>)&#XA0;=&#XA0;</EM></FONT></FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT COLOR=black><FONT SIZE=3><EM>&#X23A7;<BR>
&#X23AA;<BR>
&#X23A8;<BR>
&#X23AA;<BR>
&#X23A9;</EM></FONT></FONT></TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><FONT COLOR=black><FONT SIZE=3><EM>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;<I>n</I>+1</EM></FONT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=black><FONT SIZE=3><EM>if </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>&#XA0;<I>m</I>&#XA0;=&#XA0;0&#XA0;</EM></FONT></FONT></TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=black><FONT SIZE=3><EM>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;<I>A</I>(<I>m</I>&#X2212;1,&#XA0;1)</EM></FONT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=black><FONT SIZE=3><EM>if </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>&#XA0;<I>m</I>&#XA0;&gt;&#XA0;0&#XA0;</EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> and </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>&#XA0;<I>n</I>&#XA0;=&#XA0;0&#XA0;</EM></FONT></FONT></TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=black><FONT SIZE=3><EM><I>A</I>(<I>m</I>&#X2212;1,&#XA0;<I>A</I>(<I>m</I>,&#XA0;<I>n</I>&#X2212;1))</EM></FONT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=black><FONT SIZE=3><EM>if </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>&#XA0;<I>m</I>&#XA0;&gt;&#XA0;0&#XA0;</EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> and </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>&#XA0;<I>n</I>&#XA0;&gt;&#XA0;0.</EM></FONT></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><FONT COLOR=black><FONT SIZE=3><EM>&nbsp;</EM></FONT></FONT></TD><TD ALIGN=left NOWRAP><FONT COLOR=black><FONT SIZE=3><EM>&nbsp;</EM></FONT></FONT></TD><TD ALIGN=right NOWRAP><FONT COLOR=black><FONT SIZE=3><EM>&#XA0;&#XA0;&#XA0;&#XA0;(1)</EM></FONT></FONT></TD></TR>
</TABLE></TD></TR>
</TABLE><P><FONT COLOR=black><FONT SIZE=3><EM>
Write a function named </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>ack</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> that evaluates Ackerman&#X2019;s function.
Use your function to evaluate </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>ack(3, 4)</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>, which should be 125.
What happens for larger values of </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>m</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> and </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>n</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>?</EM></FONT></FONT></P></DIV><DIV CLASS="theorem"><FONT COLOR=black><FONT SIZE=3><B>Exercise&#XA0;6</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;<EM>
</EM></FONT></FONT><A NAME="palindrome"></A><P><A NAME="@default512"></A></P><P><FONT COLOR=black><FONT SIZE=3><EM>A palindrome is a word that is spelled the same backward and
forward, like &#X201C;noon&#X201D; and &#X201C;redivider&#X201D;. Recursively, a word
is a palindrome if the first and last letters are the same
and the middle is a palindrome.</EM></FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3><EM>The following are functions that take a string argument and
return the first, last, and middle letters:</EM></FONT></FONT></P><PRE CLASS="verbatim"><EM><FONT COLOR=blue><FONT SIZE=4>def first(word):
    return word[0]

def last(word):
    return word[-1]

def middle(word):
    return word[1:-1]
</FONT></FONT></EM></PRE><P><EM><FONT COLOR=black><FONT SIZE=3>We&#X2019;ll see how they work in Chapter&#XA0;</FONT></FONT></EM><A HREF="book009.html#strings"><EM><FONT COLOR=black><FONT SIZE=3>8</FONT></FONT></EM></A><EM><FONT COLOR=black><FONT SIZE=3>.</FONT></FONT></EM></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><EM><FONT COLOR=black><FONT SIZE=3>Type these functions into a file named </FONT></FONT></EM><EM><FONT COLOR=black><FONT SIZE=3><TT>palindrome.py</TT></FONT></FONT></EM><EM><FONT COLOR=black><FONT SIZE=3>
and test them out. What happens if you call </FONT></FONT></EM><EM><FONT COLOR=black><FONT SIZE=3><TT>middle</TT></FONT></FONT></EM><EM><FONT COLOR=black><FONT SIZE=3> with
a string with two letters? One letter? What about the empty
string, which is written </FONT></FONT></EM><CODE><EM><FONT COLOR=black><FONT SIZE=3>''</FONT></FONT></EM></CODE><EM><FONT COLOR=black><FONT SIZE=3> and contains no letters?</FONT></FONT></EM></LI><LI CLASS="li-enumerate"><EM><FONT COLOR=black><FONT SIZE=3>Write a function called </FONT></FONT></EM><CODE><EM><FONT COLOR=black><FONT SIZE=3>is_palindrome</FONT></FONT></EM></CODE><EM><FONT COLOR=black><FONT SIZE=3> that takes
a string argument and returns </FONT></FONT></EM><EM><FONT COLOR=black><FONT SIZE=3><TT>True</TT></FONT></FONT></EM><EM><FONT COLOR=black><FONT SIZE=3> if it is a palindrome
and </FONT></FONT></EM><EM><FONT COLOR=black><FONT SIZE=3><TT>False</TT></FONT></FONT></EM><EM><FONT COLOR=black><FONT SIZE=3> otherwise. Remember that you can use the
built-in function </FONT></FONT></EM><EM><FONT COLOR=black><FONT SIZE=3><TT>len</TT></FONT></FONT></EM><EM><FONT COLOR=black><FONT SIZE=3> to check the length of a string.</FONT></FONT></EM></LI></OL></DIV><DIV CLASS="theorem"><FONT COLOR=black><FONT SIZE=3><B>Exercise&#XA0;7</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;<EM>
A number, </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><I>a</I></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>, is a power of </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><I>b</I></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> if it is divisible by </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><I>b</I></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>
and </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><I>a</I>/<I>b</I></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> is a power of </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><I>b</I></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>. Write a function called
</EM></FONT></FONT><CODE><FONT COLOR=black><FONT SIZE=3><EM>is_power</EM></FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3><EM> that takes parameters </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>a</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> and </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>b</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>
and returns </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>True</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> if </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>a</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> is a power of </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>b</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>.
</EM></FONT></FONT></DIV><DIV CLASS="theorem"><FONT COLOR=black><FONT SIZE=3><B>Exercise&#XA0;8</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;</FONT></FONT><P><A NAME="@default513"></A><FONT COLOR=black><FONT SIZE=3><EM>
</EM></FONT></FONT><A NAME="@default514"></A></P><P><FONT COLOR=black><FONT SIZE=3><EM>The greatest common divisor (GCD) of </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><I>a</I></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> and </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><I>b</I></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> is the largest number
that divides both of them with no remainder</EM></FONT></FONT><SUP><A NAME="text11" HREF="#note11"><FONT COLOR=black><FONT SIZE=3><EM>4</EM></FONT></FONT></A></SUP><FONT COLOR=black><FONT SIZE=3><EM>.</EM></FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3><EM>One way to find the GCD of two numbers is Euclid&#X2019;s algorithm,
which is based on the observation that if </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><I>r</I></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> is the remainder
when </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><I>a</I></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> is divided by </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><I>b</I></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>, then </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><I>gcd</I>(<I>a</I>, <I>b</I>) = <I>gcd</I>(<I>b</I>, <I>r</I>)</EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>.
As a base case, we can consider </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><I>gcd</I>(<I>a</I>, 0) = <I>a</I></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>.</EM></FONT></FONT></P><P><A NAME="@default515"></A><FONT COLOR=black><FONT SIZE=3><EM>
</EM></FONT></FONT><A NAME="@default516"></A></P><P><FONT COLOR=black><FONT SIZE=3><EM>Write a function called
</EM></FONT></FONT><CODE><FONT COLOR=black><FONT SIZE=3><EM>gcd</EM></FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3><EM> that takes parameters </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>a</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> and </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>b</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>
and returns their greatest common divisor. If you need
help, see </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>wikipedia.org/wiki/Euclidean_algorithm</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>.</EM></FONT></FONT></P></DIV><HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes"><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="note8" HREF="#text8"><FONT COLOR=black><FONT SIZE=3>1</FONT></FONT></A></DT><DD CLASS="dd-thefootnotes"><FONT COLOR=black><FONT SIZE=3>See
<TT>wikipedia.org/wiki/Fibonacci_number</TT>.
</FONT></FONT></DD><DT CLASS="dt-thefootnotes"><A NAME="note9" HREF="#text9"><FONT COLOR=black><FONT SIZE=3>2</FONT></FONT></A></DT><DD CLASS="dd-thefootnotes"><FONT COLOR=black><FONT SIZE=3>See
<TT>wikipedia.org/wiki/Gamma_function</TT>.
</FONT></FONT></DD><DT CLASS="dt-thefootnotes"><A NAME="note10" HREF="#text10"><FONT COLOR=black><FONT SIZE=3>3</FONT></FONT></A></DT><DD CLASS="dd-thefootnotes"><FONT COLOR=black><FONT SIZE=3>See
<TT>wikipedia.org/wiki/Ackermann_function</TT>
</FONT></FONT></DD><DT CLASS="dt-thefootnotes"><A NAME="note11" HREF="#text11"><FONT COLOR=black><FONT SIZE=3>4</FONT></FONT></A></DT><DD CLASS="dd-thefootnotes"><FONT COLOR=black><FONT SIZE=3>This exercise is
based on an example from Abelson and Sussman&#X2019;s <EM>Structure and
Interpretation of Computer Programs</EM>.
</FONT></FONT></DD></DL>
<HR>
<A HREF="book006.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="book008.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
