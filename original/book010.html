<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Case study: word play</TITLE>
</HEAD>
<BODY >
<A HREF="book009.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="book011.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc108"><FONT COLOR=black><FONT SIZE=3>Chapter&#XA0;9</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Case study: word play</FONT></FONT></H1><H2 CLASS="section"><A NAME="toc98"></A><A NAME="htoc109"><FONT COLOR=black><FONT SIZE=3>9.1</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Reading word lists</FONT></FONT></H2><P><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="wordlist"></A></P><P><FONT COLOR=black><FONT SIZE=3>For the exercises in this chapter we need a list of English words.
There are lots of word lists available on the Web, but the one most
suitable for our purpose is one of the word lists collected and
contributed to the public domain by Grady Ward as part of the Moby
lexicon project</FONT></FONT><SUP><A NAME="text15" HREF="#note15"><FONT COLOR=black><FONT SIZE=3>1</FONT></FONT></A></SUP><FONT COLOR=black><FONT SIZE=3>. It
is a list of 113,809 official crosswords; that is, words that are
considered valid in crossword puzzles and other word games. In the
Moby collection, the filename is </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>113809of.fic</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>; I include a copy
of this file, with the simpler name </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>words.txt</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, along with
Swampy.</FONT></FONT></P><P><A NAME="@default668"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default669"></A></P><P><FONT COLOR=black><FONT SIZE=3>This file is in plain text, so you can open it with a text
editor, but you can also read it from Python. The built-in
function </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>open</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> takes the name of the file as a parameter
and returns a </FONT></FONT><FONT COLOR=black><FONT SIZE=3><B>file object</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3> you can use to read the file.</FONT></FONT></P><P><A NAME="@default670"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default671"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default672"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default673"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default674"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default675"></A></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>&gt;&gt;&gt; fin = open('words.txt')
&gt;&gt;&gt; print fin
&lt;open file 'words.txt', mode 'r' at 0xb7f4b380&gt;
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3><TT>fin</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> is a common name for a file object used for
input. Mode </FONT></FONT><CODE><FONT COLOR=black><FONT SIZE=3>'r'</FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3> indicates that this file is open for
reading (as opposed to </FONT></FONT><CODE><FONT COLOR=black><FONT SIZE=3>'w'</FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3> for writing).</FONT></FONT></P><P><A NAME="@default676"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default677"></A></P><P><FONT COLOR=black><FONT SIZE=3>The file object provides several methods for reading, including
</FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>readline</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, which reads characters from the file
until it gets to a newline and returns the result as a
string:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>&gt;&gt;&gt; fin.readline()
'aa\r\n'
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>The first word in this particular list is &#X201C;aa,&#X201D; which is a kind of
lava. The sequence </FONT></FONT><CODE><FONT COLOR=black><FONT SIZE=3>\r\n</FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3> represents two whitespace characters,
a carriage return and a newline, that separate this word from the
next.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>The file object keeps track of where it is in the file, so
if you call </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>readline</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> again, you get the next word:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>&gt;&gt;&gt; fin.readline()
'aah\r\n'
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>The next word is &#X201C;aah,&#X201D; which is a perfectly legitimate
word, so stop looking at me like that.
Or, if it&#X2019;s the whitespace that&#X2019;s bothering you,
we can get rid of it with the string method </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>strip</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>:</FONT></FONT></P><P><A NAME="@default678"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default679"></A></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>&gt;&gt;&gt; line = fin.readline()
&gt;&gt;&gt; word = line.strip()
&gt;&gt;&gt; print word
aahed
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>You can also use a file object as part of a </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>for</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> loop.
This program reads </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>words.txt</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> and prints each word, one
per line:</FONT></FONT></P><P><A NAME="@default680"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default681"></A></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>fin = open('words.txt')
for line in fin:
    word = line.strip()
    print word
</FONT></FONT></PRE><DIV CLASS="theorem"><FONT COLOR=black><FONT SIZE=3><B>Exercise&#XA0;1</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;<EM>
Write a program that reads </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>words.txt</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> and prints only the
words with more than 20 characters (not counting whitespace).</EM></FONT></FONT><P><A NAME="@default682"></A></P></DIV><H2 CLASS="section"><A NAME="toc99"></A><A NAME="htoc110"><FONT COLOR=black><FONT SIZE=3>9.2</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Exercises</FONT></FONT></H2><P><FONT COLOR=black><FONT SIZE=3>There are solutions to these exercises in the next section.
You should at least attempt each one before you read the solutions.</FONT></FONT></P><DIV CLASS="theorem"><FONT COLOR=black><FONT SIZE=3><B>Exercise&#XA0;2</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;<EM>
In 1939 Ernest Vincent Wright published a 50,000 word novel called
</EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3>Gadsby</FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> that does not contain the letter &#X201C;e.&#X201D; Since &#X201C;e&#X201D; is
the most common letter in English, that&#X2019;s not easy to do.</EM></FONT></FONT><P><FONT COLOR=black><FONT SIZE=3><EM>In fact, it is difficult to construct a solitary thought without using
that most common symbol. It is slow going at first, but with caution
and hours of training you can gradually gain facility.</EM></FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3><EM>All right, I&#X2019;ll stop now.</EM></FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3><EM>Write a function called </EM></FONT></FONT><CODE><FONT COLOR=black><FONT SIZE=3><EM>has_no_e</EM></FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3><EM> that returns </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>True</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> if
the given word doesn&#X2019;t have the letter &#X201C;e&#X201D; in it.</EM></FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3><EM>Modify your program from the previous section to print only the words
that have no &#X201C;e&#X201D; and compute the percentage of the words in the list
have no &#X201C;e.&#X201D;</EM></FONT></FONT></P><P><A NAME="@default683"></A></P></DIV><DIV CLASS="theorem"><FONT COLOR=black><FONT SIZE=3><B>Exercise&#XA0;3</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;<EM> 
Write a function named </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>avoids</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>
that takes a word and a string of forbidden letters, and
that returns </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>True</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> if the word doesn&#X2019;t use any of the forbidden
letters.</EM></FONT></FONT><P><FONT COLOR=black><FONT SIZE=3><EM>Modify your program to prompt the user to enter a string
of forbidden letters and then print the number of words that
don&#X2019;t contain any of them.
Can you find a combination of 5 forbidden letters that
excludes the smallest number of words?
</EM></FONT></FONT></P></DIV><DIV CLASS="theorem"><FONT COLOR=black><FONT SIZE=3><B>Exercise&#XA0;4</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;<EM>
Write a function named </EM></FONT></FONT><CODE><FONT COLOR=black><FONT SIZE=3><EM>uses_only</EM></FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3><EM> that takes a word and a
string of letters, and that returns </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>True</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> if the word contains
only letters in the list. Can you make a sentence using only the
letters </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>acefhlo</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>? Other than &#X201C;Hoe alfalfa?&#X201D;
</EM></FONT></FONT></DIV><DIV CLASS="theorem"><FONT COLOR=black><FONT SIZE=3><B>Exercise&#XA0;5</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;<EM> 
Write a function named </EM></FONT></FONT><CODE><FONT COLOR=black><FONT SIZE=3><EM>uses_all</EM></FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3><EM> that takes a word and a
string of required letters, and that returns </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>True</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> if the word
uses all the required letters at least once. How many words are there
that use all the vowels </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>aeiou</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>? How about </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>aeiouy</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>?
</EM></FONT></FONT></DIV><DIV CLASS="theorem"><FONT COLOR=black><FONT SIZE=3><B>Exercise&#XA0;6</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;<EM>
Write a function called </EM></FONT></FONT><CODE><FONT COLOR=black><FONT SIZE=3><EM>is_abecedarian</EM></FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3><EM> that returns
</EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>True</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> if the letters in a word appear in alphabetical order
(double letters are ok). 
How many abecedarian words are there?
</EM></FONT></FONT></DIV><P><A NAME="@default684"></A></P><H2 CLASS="section"><A NAME="toc100"></A><A NAME="htoc111"><FONT COLOR=black><FONT SIZE=3>9.3</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Search</FONT></FONT></H2><P><A NAME="@default685"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default686"></A></P><P><FONT COLOR=black><FONT SIZE=3>All of the exercises in the previous section have something
in common; they can be solved with the search pattern we saw
in Section&#XA0;</FONT></FONT><A HREF="book009.html#find"><FONT COLOR=black><FONT SIZE=3>8.6</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>. The simplest example is:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def has_no_e(word):
    for letter in word:
        if letter == 'e':
            return False
    return True
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>The </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>for</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> loop traverses the characters in </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>word</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>. If we find
the letter &#X201C;e&#X201D;, we can immediately return </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>False</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>; otherwise we
have to go to the next letter. If we exit the loop normally, that
means we didn&#X2019;t find an &#X201C;e&#X201D;, so we return </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>True</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>.</FONT></FONT></P><P><A NAME="@default687"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default688"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default689"></A></P><P><FONT COLOR=black><FONT SIZE=3>You can write this function more concisely using the </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>in</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>
operator, but I started with this version because it 
demonstrates the logic of the search pattern.</FONT></FONT></P><P><A NAME="@default690"></A></P><P><FONT COLOR=black><FONT SIZE=3><TT>avoids</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> is a more general version of </FONT></FONT><CODE><FONT COLOR=black><FONT SIZE=3>has_no_e</FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3> but it
has the same structure:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def avoids(word, forbidden):
    for letter in word:
        if letter in forbidden:
            return False
    return True
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>We can return </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>False</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> as soon as we find a forbidden letter;
if we get to the end of the loop, we return </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>True</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>.</FONT></FONT></P><P><CODE><FONT COLOR=black><FONT SIZE=3>uses_only</FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3> is similar except that the sense of the condition
is reversed:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def uses_only(word, available):
    for letter in word: 
        if letter not in available:
            return False
    return True
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>Instead of a list of forbidden words, we have a list of available
words. If we find a letter in </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>word</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> that is not in
</FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>available</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, we can return </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>False</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>.</FONT></FONT></P><P><CODE><FONT COLOR=black><FONT SIZE=3>uses_all</FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3> is similar except that we reverse the role
of the word and the string of letters:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def uses_all(word, required):
    for letter in required: 
        if letter not in word:
            return False
    return True
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>Instead of traversing the letters in </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>word</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, the loop
traverses the required letters. If any of the required letters
do not appear in the word, we can return </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>False</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>.</FONT></FONT></P><P><A NAME="@default691"></A></P><P><FONT COLOR=black><FONT SIZE=3>If you were really thinking like a computer scientist, you would
have recognized that </FONT></FONT><CODE><FONT COLOR=black><FONT SIZE=3>uses_all</FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3> was an instance of a
previously-solved problem, and you would have written:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def uses_all(word, required):
    return uses_only(required, word)
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>This is an example of a program development method called </FONT></FONT><FONT COLOR=black><FONT SIZE=3><B>problem
recognition</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, which means that you recognize the problem you are
working on as an instance of a previously-solved problem, and apply a
previously-developed solution.</FONT></FONT></P><P><A NAME="@default692"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default693"></A></P><H2 CLASS="section"><A NAME="toc101"></A><A NAME="htoc112"><FONT COLOR=black><FONT SIZE=3>9.4</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Looping with indices</FONT></FONT></H2><P><A NAME="@default694"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default695"></A></P><P><FONT COLOR=black><FONT SIZE=3>I wrote the functions in the previous section with </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>for</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>
loops because I only needed the characters in the strings; I didn&#X2019;t
have to do anything with the indices.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>For </FONT></FONT><CODE><FONT COLOR=black><FONT SIZE=3>is_abecedarian</FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3> we have to compare adjacent letters,
which is hard to do with a </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>for</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> loop. One option is to
use recursion:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def is_abecedarian(word):
    if len(word) &lt;= 1:
        return True
    if word[0] &gt; word[1]:
        return False
    return is_abecedarian(word[1:])
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>Another option is to use a </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>while</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> loop:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def is_abecedarian(word):
    i = 0
    while i &lt; len(word)-1:
        if word[i+1] &lt; word[i]:
            return False
        i = i+1
    return True
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>The loop starts at </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>i=0</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> and ends when </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>i=len(word)-1</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>. Each
time through the loop, it compares the </FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>i</I></FONT></FONT><FONT COLOR=black><FONT SIZE=3>th character (which you can
think of as the current character) to the </FONT></FONT><FONT COLOR=black><FONT SIZE=3><I>i</I>+1</FONT></FONT><FONT COLOR=black><FONT SIZE=3>th character (which you
can think of as the next).</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>If the next character is less than (alphabetically before) the current
one, then we have discovered a break in the abecedarian trend, and
we return </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>False</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>If we get to the end of the loop without finding a fault, then the
word passes the test. To convince yourself that the loop ends
correctly, consider an example like </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>&#X2019;flossy&#X2019;</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>. The
length of the word is 6, so
the last time the loop runs is when </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>i</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3> is 4, which is the
index of the second-to-last character. On the last iteration,
it compares the second-to-last character to the last, which is
what we want.</FONT></FONT></P><P><A NAME="@default696"></A></P><P><FONT COLOR=black><FONT SIZE=3>Here is a version of </FONT></FONT><CODE><FONT COLOR=black><FONT SIZE=3>is_palindrome</FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3> (see
Exercise&#XA0;</FONT></FONT><A HREF="book007.html#palindrome"><FONT COLOR=black><FONT SIZE=3>6.6</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>) that uses two indices; one starts at the
beginning and goes up; the other starts at the end and goes down.</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def is_palindrome(word):
    i = 0
    j = len(word)-1

    while i&lt;j:
        if word[i] != word[j]:
            return False
        i = i+1
        j = j-1

    return True
</FONT></FONT></PRE><P><FONT COLOR=black><FONT SIZE=3>Or, if you noticed that this is an instance of a previously-solved
problem, you might have written:</FONT></FONT></P><PRE CLASS="verbatim"><FONT COLOR=blue><FONT SIZE=4>def is_palindrome(word):
    return is_reverse(word, word)
</FONT></FONT></PRE><P><A NAME="@default697"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default698"></A></P><P><FONT COLOR=black><FONT SIZE=3>Assuming you did Exercise&#XA0;</FONT></FONT><A HREF="book009.html#is_reverse"><FONT COLOR=black><FONT SIZE=3>8.8</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>.</FONT></FONT></P><H2 CLASS="section"><A NAME="toc102"></A><A NAME="htoc113"><FONT COLOR=black><FONT SIZE=3>9.5</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Debugging</FONT></FONT></H2><P><A NAME="@default699"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default700"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default701"></A></P><P><FONT COLOR=black><FONT SIZE=3>Testing programs is hard. The functions in this chapter are
relatively easy to test because you can check the results by hand.
Even so, it is somewhere between difficult and impossible to choose a
set of words that test for all possible errors.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>Taking </FONT></FONT><CODE><FONT COLOR=black><FONT SIZE=3>has_no_e</FONT></FONT></CODE><FONT COLOR=black><FONT SIZE=3> as an example, there are two obvious
cases to check: words that have an &#X2019;e&#X2019; should return </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>False</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>;
words that don&#X2019;t should return </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>True</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>. You should have no
trouble coming up with one of each.</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>Within each case, there are some less obvious subcases. Among the
words that have an &#X201C;e,&#X201D; you should test words with an &#X201C;e&#X201D; at the
beginning, the end, and somewhere in the middle. You should test long
words, short words, and very short words, like the empty string. The
empty string is an example of a </FONT></FONT><FONT COLOR=black><FONT SIZE=3><B>special case</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>, which is one of
the non-obvious cases where errors often lurk.</FONT></FONT></P><P><A NAME="@default702"></A></P><P><FONT COLOR=black><FONT SIZE=3>In addition to the test cases you generate, you can also test
your program with a word list like </FONT></FONT><FONT COLOR=black><FONT SIZE=3><TT>words.txt</TT></FONT></FONT><FONT COLOR=black><FONT SIZE=3>. By scanning
the output, you might be able to catch errors, but be careful:
you might catch one kind of error (words that should not be
included, but are) and not another (words that should be included,
but aren&#X2019;t).</FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3>In general, testing can help you find bugs, but it is not easy to
generate a good set of test cases, and even if you do, you can&#X2019;t
be sure your program is correct.</FONT></FONT></P><P><A NAME="@default703"></A></P><P><FONT COLOR=black><FONT SIZE=3>According to a legendary computer scientist:</FONT></FONT></P><BLOCKQUOTE CLASS="quote"><FONT COLOR=black><FONT SIZE=3>
Program testing can be used to show the presence of bugs, but never to
show their absence!</FONT></FONT><P><FONT COLOR=black><FONT SIZE=3>&#X2014; Edsger W. Dijkstra
</FONT></FONT></P></BLOCKQUOTE><P><A NAME="@default704"></A></P><H2 CLASS="section"><A NAME="toc103"></A><A NAME="htoc114"><FONT COLOR=black><FONT SIZE=3>9.6</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Glossary</FONT></FONT></H2><DL CLASS="description"><DT CLASS="dt-description"><FONT COLOR=black><FONT SIZE=3><B>file object:</B></FONT></FONT></DT><DD CLASS="dd-description"><FONT COLOR=black><FONT SIZE=3> A value that represents an open file.
</FONT></FONT><A NAME="@default705"></A><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="@default706"></A></DD><DT CLASS="dt-description"><FONT COLOR=black><FONT SIZE=3><B>problem recognition:</B></FONT></FONT></DT><DD CLASS="dd-description"><FONT COLOR=black><FONT SIZE=3> A way of solving a problem by
expressing it as an instance of a previously-solved problem.
</FONT></FONT><A NAME="@default707"></A></DD><DT CLASS="dt-description"><FONT COLOR=black><FONT SIZE=3><B>special case:</B></FONT></FONT></DT><DD CLASS="dd-description"><FONT COLOR=black><FONT SIZE=3> A test case that is atypical or non-obvious
(and less likely to be handled correctly).
</FONT></FONT><A NAME="@default708"></A></DD></DL><H2 CLASS="section"><A NAME="toc104"></A><A NAME="htoc115"><FONT COLOR=black><FONT SIZE=3>9.7</FONT></FONT></A><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;Exercises</FONT></FONT></H2><DIV CLASS="theorem"><FONT COLOR=black><FONT SIZE=3><B>Exercise&#XA0;7</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;</FONT></FONT><P><A NAME="@default709"></A><FONT COLOR=black><FONT SIZE=3><EM>
</EM></FONT></FONT><A NAME="@default710"></A><FONT COLOR=black><FONT SIZE=3><EM>
</EM></FONT></FONT><A NAME="@default711"></A></P><P><FONT COLOR=black><FONT SIZE=3><EM>This question is based on a Puzzler that was broadcast on the radio
program </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3>Car
Talk</FONT></FONT><SUP><A NAME="text16" HREF="#note16"><FONT COLOR=black><FONT SIZE=3><EM>2</EM></FONT></FONT></A></SUP><FONT COLOR=black><FONT SIZE=3><EM>:</EM></FONT></FONT></P><BLOCKQUOTE CLASS="quote"><FONT COLOR=black><FONT SIZE=3><EM>
Give me a word with three consecutive double letters. I&#X2019;ll give you a
couple of words that almost qualify, but don&#X2019;t. For example, the word
committee, c-o-m-m-i-t-t-e-e. It would be great except for the &#X2018;i&#X2019; that
sneaks in there. Or Mississippi: M-i-s-s-i-s-s-i-p-p-i. If you could
take out those i&#X2019;s it would work. But there is a word that has three
consecutive pairs of letters and to the best of my knowledge this may
be the only word. Of course there are probably 500 more but I can only
think of one. What is the word?
</EM></FONT></FONT></BLOCKQUOTE><P><FONT COLOR=black><FONT SIZE=3><EM>Write a program to find it. You can see my solution at
</EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>thinkpython.com/code/cartalk.py</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>.</EM></FONT></FONT></P></DIV><DIV CLASS="theorem"><FONT COLOR=black><FONT SIZE=3><B>Exercise&#XA0;8</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;<EM>
Here&#X2019;s another </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3>Car Talk</FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>
Puzzler</EM></FONT></FONT><SUP><A NAME="text17" HREF="#note17"><FONT COLOR=black><FONT SIZE=3><EM>3</EM></FONT></FONT></A></SUP><FONT COLOR=black><FONT SIZE=3><EM>:</EM></FONT></FONT><P><A NAME="@default712"></A><FONT COLOR=black><FONT SIZE=3><EM>
</EM></FONT></FONT><A NAME="@default713"></A><FONT COLOR=black><FONT SIZE=3><EM>
</EM></FONT></FONT><A NAME="@default714"></A><FONT COLOR=black><FONT SIZE=3><EM>
</EM></FONT></FONT><A NAME="@default715"></A></P><BLOCKQUOTE CLASS="quote"><FONT COLOR=black><FONT SIZE=3><EM>
&#X201C;I was driving on the highway the other day and I happened to
notice my odometer. Like most odometers, it shows six digits,
in whole miles only. So, if my car had 300,000
miles, for example, I&#X2019;d see 3-0-0-0-0-0.</EM></FONT></FONT><P><FONT COLOR=black><FONT SIZE=3><EM>&#X201C;Now, what I saw that day was very interesting. I noticed that the
last 4 digits were palindromic; that is, they read the same forward as
backward. For example, 5-4-4-5 is a palindrome, so my odometer
could have read 3-1-5-4-4-5.</EM></FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3><EM>&#X201C;One mile later, the last 5 numbers were palindromic. For example, it
could have read 3-6-5-4-5-6. One mile after that, the middle 4 out of
6 numbers were palindromic. And you ready for this? One mile later,
all 6 were palindromic!</EM></FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3><EM>&#X201C;The question is, what was on the odometer when I first looked?&#X201D;
</EM></FONT></FONT></P></BLOCKQUOTE><P><FONT COLOR=black><FONT SIZE=3><EM>Write a Python program that tests all the six-digit numbers and prints
any numbers that satisfy these requirements. You can see my solution
at </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>thinkpython.com/code/cartalk.py</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>.</EM></FONT></FONT></P></DIV><DIV CLASS="theorem"><FONT COLOR=black><FONT SIZE=3><B>Exercise&#XA0;9</B></FONT></FONT><FONT COLOR=black><FONT SIZE=3>&#XA0;&#XA0;<EM>
Here&#X2019;s another </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3>Car Talk</FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> Puzzler you can solve with a
search</EM></FONT></FONT><SUP><A NAME="text18" HREF="#note18"><FONT COLOR=black><FONT SIZE=3><EM>4</EM></FONT></FONT></A></SUP><FONT COLOR=black><FONT SIZE=3><EM>:</EM></FONT></FONT><P><A NAME="@default716"></A><FONT COLOR=black><FONT SIZE=3><EM>
</EM></FONT></FONT><A NAME="@default717"></A><FONT COLOR=black><FONT SIZE=3><EM>
</EM></FONT></FONT><A NAME="@default718"></A></P><BLOCKQUOTE CLASS="quote"><FONT COLOR=black><FONT SIZE=3><EM>
&#X201C;Recently I had a visit with my mom and we realized that
the two digits that make up my age when reversed resulted in her
age. For example, if she&#X2019;s 73, I&#X2019;m 37. We wondered how often this has
happened over the years but we got sidetracked with other topics and
we never came up with an answer.</EM></FONT></FONT><P><FONT COLOR=black><FONT SIZE=3><EM>&#X201C;When I got home I figured out that the digits of our ages have been
reversible six times so far. I also figured out that if we&#X2019;re lucky it
would happen again in a few years, and if we&#X2019;re really lucky it would
happen one more time after that. In other words, it would have
happened 8 times over all. So the question is, how old am I now?&#X201D;</EM></FONT></FONT></P></BLOCKQUOTE><P><FONT COLOR=black><FONT SIZE=3><EM>Write a Python program that searches for solutions to this Puzzler.
Hint: you might find the string method </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>zfill</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM> useful.</EM></FONT></FONT></P><P><FONT COLOR=black><FONT SIZE=3><EM>You can see my solution at </EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM><TT>thinkpython.com/code/cartalk.py</TT></EM></FONT></FONT><FONT COLOR=black><FONT SIZE=3><EM>.</EM></FONT></FONT></P></DIV><HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes"><FONT COLOR=black><FONT SIZE=3>
</FONT></FONT><A NAME="note15" HREF="#text15"><FONT COLOR=black><FONT SIZE=3>1</FONT></FONT></A></DT><DD CLASS="dd-thefootnotes"><FONT COLOR=black><FONT SIZE=3><TT>wikipedia.org/wiki/Moby_Project</TT>
</FONT></FONT></DD><DT CLASS="dt-thefootnotes"><A NAME="note16" HREF="#text16"><FONT COLOR=black><FONT SIZE=3>2</FONT></FONT></A></DT><DD CLASS="dd-thefootnotes"><FONT COLOR=black><FONT SIZE=3><TT>www.cartalk.com/content/puzzler/transcripts/200725</TT>
</FONT></FONT></DD><DT CLASS="dt-thefootnotes"><A NAME="note17" HREF="#text17"><FONT COLOR=black><FONT SIZE=3>3</FONT></FONT></A></DT><DD CLASS="dd-thefootnotes"><FONT COLOR=black><FONT SIZE=3><TT>www.cartalk.com/content/puzzler/transcripts/200803</TT>
</FONT></FONT></DD><DT CLASS="dt-thefootnotes"><A NAME="note18" HREF="#text18"><FONT COLOR=black><FONT SIZE=3>4</FONT></FONT></A></DT><DD CLASS="dd-thefootnotes"><FONT COLOR=black><FONT SIZE=3><TT>www.cartalk.com/content/puzzler/transcripts/200813</TT>
</FONT></FONT></DD></DL>
<HR>
<A HREF="book009.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="book011.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
